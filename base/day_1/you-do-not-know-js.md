# day_1
1. 引擎: 负责整个js程序的编译和执行过程
2. 编译器: 负责语法分析和代码生成
3. 作用域: 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并且实施一套非常严格的规则，确定当前执行的代码对这些标志符有访问权限。
分析:`var a = 1;`
- 声明a: 当前作用域是否有a,如果有，跳过声明，如果没有声明a
- 给a赋值: 从作用域查找是否有a,如果有，给a赋值，如果没有继续查找

## LHS,RHS
当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。
**RHS: 查找某个变量的值, 谁是赋值操作的源头**
**LHS: 找到变量的容器, 赋值操作的目标是谁**
LHS: 对谁赋值
RHS: 把谁的值赋值给变量
```js
function foo(a){
    console.log(a);
}
foo(2);
```
RHS: foo
LHS: a
RHS: console
RHS: a
```js
function foo(a){
    var b = a; // 找到a的值
    return a + b; // 找到a的值，找到b的值
}
var c = foo(2); // 找到foo的值
```
LHS: c
RHS: foo
LHS: a
LHS: b
RHS: a
RHS: a
RHS: b

LHS:3
RHS:4
??不知道是不是对
描述上面代码的LHS和RHS:
LHS: 
- 查找foo
- 查找a
- 查找b
RHS:
- 找到a的值
- 找到a的值
- 找到b的值
- 找到foo的值

## 词法作用域

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。
作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

欺骗词法作用域会导致性能下降。
JavaScript中的eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
在执行eval(..)之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找
在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
JavaScript中还有其他一些功能效果和eval(..)很相似。setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..)略微安全一些，但也要尽量避免使用。
JavaScript中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with关键字。
with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。
```js
var obj = {
    a: 1,
    b: 2,
    c: 3
};
obj.a = 2;
obj.b = 3;
obj.c = 4;
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```
with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。
JavaScript中有两个机制可以“欺骗”词法作用域：eval(..)和with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

## 函数作用域和块作用域
无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）

为什么“隐藏”变量和函数是一个有用的技术？
有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。
“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

首先，包装函数的声明以(function..．而不仅是以function..．开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。
区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
