# `a.x = a = {n:2}`
```js
var c = {};
c.a = c = [];
//c.a = ?
var a = {n:1};
a.x = a = {n:2};
// a.x = ?
```
1. 单纯的`var x;`中的`x`就是一个语法分析时用到的标识符。
2. `x = 100;`中`x`就是表达式了，这时候用到了`LHS`
3. js计算表达式的顺序始终是**从左到右**
解释下上面的代码:
上面的代码实际上是进行了两次赋值
第一次`a.x = a`
第二次`a = {n:2}`
这就很简单了`{n:2}`中是没有`x`属性的，所以，`a.x=undefined`.
实际应用:构建一个嵌套的层次结构
```js
var c = {value: null}, root = c;
var i = 0;
while(i < 10){
    c.next = c = {value: i};
    i++;
}
var iter = root.next;
while(iter){
    console.log(iter.value);// 0~9
    iter = iter.next;
}
```
上面类似一个链表,root保存了头.

1. 试解析with ({x:100}) delete x; 将发生什么。
将删除x属性，这里的x是传入对象的属性
2. 试说明(eval)()与(0, eval)()的不同。
多了一个逗号运算,逗号运算的作用就是先计算左边的值，再计算右边的值，然后返回右边的值。
3. 设“a.x === 0”，试说明“(a.x) = 1”为什么可行。
(a.x)返回的是a对象属性x的引用，所以可行
4. 为什么with (obj={}) x = 100; 不会给 obj 添加一个属性’x’？
x不是obj的属性，所以，会出现变量泄露给全局作用域
